{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DiffGuard","text":"<p>Catches the structural breaks that pass code review.</p>"},{"location":"#a-real-bug-in-one-line","title":"A real bug, in one line","text":"<p>This diff shipped in Flask (PR #5898):</p> <pre><code>-def redirect(location, code=302, ...):\n+def redirect(location, code=303, ...):\n</code></pre> <p>One line. Looks fine. A reviewer approves it.</p> <p>The real impact: 7 endpoints silently change HTTP behavior. POST-to-POST redirects become POST-to-GET. No errors. No warnings. Just broken APIs in production.</p> <p>DiffGuard catches it:</p> <pre><code>$ diffguard review eca5fd1d~1..eca5fd1d\n\n\u26a0 DiffGuard: 2 changes need review\n\n  DEFAULT VALUE CHANGED: redirect(location, code=302) \u2192 redirect(location, code=303)\n  src/flask/helpers.py:241\n  Impact: 7 callers rely on the default:\n    auth.py:25   return redirect(url_for(\"auth.login\"))\n    auth.py:77   return redirect(url_for(\"auth.login\"))\n    auth.py:105  return redirect(url_for(\"index\"))\n    auth.py:116  return redirect(url_for(\"index\"))\n    blog.py:81   return redirect(url_for(\"blog.index\"))\n    + test_helpers.py (5 calls), test_regression.py (1), test_signals.py (1), test_testing.py (1)\n\n  DEFAULT VALUE CHANGED: App.redirect(self, location, code=302) \u2192 App.redirect(self, location, code=303)\n  src/flask/sansio/app.py:935 \u2014 7 callers rely on the default\n</code></pre> <p>Real output from DiffGuard against Flask commit <code>eca5fd1d</code>. Tree-sitter AST analysis \u2014 no LLM, no network calls, runs in seconds.</p> <p>See more examples in Real-World Catches.</p>"},{"location":"#what-it-catches","title":"What it catches","text":"<p>Function signature changes, removed/renamed symbols, default value changes \u2014 and shows you every caller affected.</p>"},{"location":"#what-it-doesnt-catch","title":"What it doesn't catch","text":"<p>Logic bugs, behavioral changes beyond signatures, performance issues, security vulnerabilities. DiffGuard detects a specific class of structural breaks, not all bugs.</p> <p>When there's nothing structural to report, it stays silent (exit code 0, no output).</p>"},{"location":"#get-started","title":"Get started","text":"<pre><code>pip install diffguard\ndiffguard review main..feature\n</code></pre> <p>Exit codes: <code>0</code> = nothing noteworthy, <code>1</code> = findings, <code>2</code> = error.</p> <p>See the Quickstart Guide for configuration, JSON output, and CI setup.</p>"},{"location":"#how-it-works","title":"How it works","text":"<ol> <li>Parses the diff using tree-sitter AST analysis (not regex)</li> <li>Extracts symbols \u2014 functions, classes, signatures</li> <li>Detects high-signal changes \u2014 signature changes, removed symbols, default value changes</li> <li>Scans for callers \u2014 finds every file that references changed symbols</li> <li>Outputs actionable context \u2014 or stays silent if nothing matters</li> </ol> <p>See How It Works for the full technical approach.</p>"},{"location":"#why-not-x","title":"Why not X?","text":"DiffGuard CodeRabbit Copilot / claude-code-action Aider repo-map Setup <code>pip install</code> (30 seconds) Account + GitHub app + config GitHub app + config Locked inside Aider Cost Free $15\u201330/seat/month Included with Copilot Free (Aider-only) Privacy Code never leaves your machine Code on their servers Code on their servers Local Works with any agent Yes \u2014 CLI + JSON GitHub PR comments only GitHub only Aider only Output Silent when nothing matters Comments on every PR Comments on every PR N/A Analysis Structural verification (AST) LLM-powered review LLM-powered review Tree-sitter map <p>These tools are complementary. Run DiffGuard first as cheap, instant structural triage. Then let the expensive model focus on what actually matters.</p>"},{"location":"#agent-integration","title":"Agent integration","text":"<p>Add one line to your agent config \u2014 DiffGuard is silent when nothing matters.</p> <ul> <li>Claude Code \u2014 Add to <code>CLAUDE.md</code> or wire as a hook. See snippet.</li> <li>Cursor \u2014 Add <code>.cursor/rules/diffguard.mdc</code>. See snippet.</li> <li>Any agent \u2014 One instruction: <code>Before reviewing diffs, run: diffguard review &lt;base&gt;..HEAD</code></li> </ul> <p>See the full Agent Integration Guide for hooks, CI patterns, and examples.</p>"},{"location":"#github-action","title":"GitHub Action","text":"<pre><code># .github/workflows/diffguard.yml\nname: DiffGuard PR Review\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\npermissions:\n  contents: read\n  pull-requests: write\njobs:\n  diffguard:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n      - uses: ostehost/diffguard@main\n</code></pre> <p>When findings exist, DiffGuard posts a PR comment. When there's nothing noteworthy, it stays silent.</p>"},{"location":"#languages","title":"Languages","text":"<ul> <li>Python \u2014 most mature, extensive real-world validation</li> <li>TypeScript / JavaScript</li> <li>Go</li> <li>More planned (Rust, Java, C#)</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<ol> <li>Silence is a feature. No findings? No output. Most diffs don't need structural analysis.</li> <li>Local-first. Your code never leaves your machine. No SaaS, no API keys, no accounts.</li> <li>Agent-native. CLI + JSON output. <code>pip install</code> and go. Works with any agent or workflow.</li> <li>Precision over recall. We'd rather miss a minor issue than cry wolf on every PR.</li> </ol>"},{"location":"agent-integration/","title":"Agent Integration Guide","text":"<p>DiffGuard works with any AI agent that can run shell commands.</p>"},{"location":"agent-integration/#quick-setup","title":"Quick setup","text":"<pre><code>pip install diffguard\n</code></pre> <p>Add one instruction to your agent's system prompt or config:</p> <pre><code>Before reviewing any diff, run: diffguard review &lt;base&gt;..HEAD\n</code></pre> <p>That's it. DiffGuard is silent (exit 0) when nothing is noteworthy, so it won't add noise.</p>"},{"location":"agent-integration/#two-commands-for-agents","title":"Two commands for agents","text":""},{"location":"agent-integration/#diffguard-review-selective-high-signal-primary","title":"<code>diffguard review</code> \u2014 selective, high-signal (primary)","text":"<pre><code>diffguard review main..HEAD --format json\n</code></pre> <p>Returns only high-signal findings: signature changes, removed symbols, default value changes. Silent when nothing matters. Best for CI gates and \"should I look closer?\" decisions.</p>"},{"location":"agent-integration/#diffguard-summarize-full-structural-map","title":"<code>diffguard summarize</code> \u2014 full structural map","text":"<pre><code>diffguard summarize main..HEAD --format json\n</code></pre> <p>Returns a complete structural summary of the diff (~200-300 tokens). Always produces output. Best when the agent needs a full map before reading the diff.</p>"},{"location":"agent-integration/#exit-codes-review-command","title":"Exit codes (review command)","text":"Code Meaning Agent action 0 No high-signal findings Continue normally 1 Findings present Read stdout, address each finding 2 Error (not a repo, bad ref) Report the error"},{"location":"agent-integration/#example-output","title":"Example output","text":""},{"location":"agent-integration/#review-text","title":"Review (text)","text":"<pre><code>\u26a0 DiffGuard: 2 changes need review\n\n1. DEFAULT VALUE CHANGED: redirect(location, code=302, Response) \u2192 redirect(location, code=303, Response)\n   File: src/flask/helpers.py:241\n   Impact: 7 callers rely on the default:\n     auth.py:25   `return redirect(url_for(\"auth.login\"))`\n     ...\n   Review: Verify callers expect the new default value\n</code></pre> <p>Real output from Flask commit <code>eca5fd1d</code>.</p>"},{"location":"agent-integration/#review-json","title":"Review (JSON)","text":"<pre><code>{\n  \"version\": \"0.1.0\",\n  \"ref_range\": \"main..HEAD\",\n  \"findings\": [\n    {\n      \"category\": \"SIGNATURE_CHANGED\",\n      \"symbol\": \"authenticate\",\n      \"file\": \"src/auth/users.py\",\n      \"line\": 34,\n      \"before_signature\": \"def authenticate(name, email)\",\n      \"after_signature\": \"def authenticate(name, email, role=\\\"viewer\\\")\",\n      \"impact\": {\n        \"production_callers\": 3,\n        \"test_callers\": 2,\n        \"callers\": [...]\n      },\n      \"review_hint\": \"Check all callers handle the new signature\"\n    }\n  ],\n  \"stats\": {\n    \"files_analyzed\": 5,\n    \"symbols_changed\": 8,\n    \"silence_reason\": null\n  }\n}\n</code></pre> <p>Illustrative example</p> <p>The JSON above shows the schema structure with realistic field values. See Schema Reference for the full specification.</p>"},{"location":"agent-integration/#claude-code","title":"Claude Code","text":"<p>Add the snippet to your repo's <code>CLAUDE.md</code> \u2014 see claude-md-snippet.md.</p>"},{"location":"agent-integration/#claude-code-hook","title":"Claude Code Hook","text":"<p>Wire DiffGuard as a hook that runs automatically after edits:</p> <p><code>.claude/settings.json</code>:</p> <pre><code>{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write|MultiEdit\",\n        \"command\": \"diffguard review HEAD~1..HEAD --format text 2&gt;/dev/null || true\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Or as a one-shot check when a task completes:</p> <pre><code>{\n  \"hooks\": {\n    \"TaskCompleted\": [\n      {\n        \"command\": \"diffguard review $(git merge-base main HEAD)..HEAD\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"agent-integration/#cursor","title":"Cursor","text":"<p>Add a rule file at <code>.cursor/rules/diffguard.mdc</code> \u2014 see cursor-rule-snippet.md.</p>"},{"location":"agent-integration/#integration-patterns","title":"Integration patterns","text":""},{"location":"agent-integration/#cicd-pre-review","title":"CI/CD pre-review","text":"<pre><code># In your CI pipeline, before AI review\nFINDINGS=$(diffguard review $BASE_SHA..HEAD --format json)\nif [ $? -eq 1 ]; then\n  echo \"$FINDINGS\" | your-agent-review-command\nfi\n</code></pre>"},{"location":"agent-integration/#git-hook","title":"Git hook","text":"<pre><code># .git/hooks/post-commit\ndiffguard review HEAD~1..HEAD\n</code></pre>"},{"location":"agent-integration/#scope","title":"Scope","text":"<p>DiffGuard catches structural breaks: signature changes, removed symbols, default value changes. It does not catch logic bugs, security issues, or performance problems. See What it catches.</p>"},{"location":"agent-integration/#supported-languages","title":"Supported languages","text":"<ul> <li>Python \u2014 most mature, extensive real-world validation</li> <li>TypeScript / JavaScript</li> <li>Go</li> <li>More planned (Rust, Java, C#)</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#pipeline","title":"Pipeline","text":"<pre><code>git diff \u2500\u2500\u2192 parse \u2500\u2500\u2192 extract \u2500\u2500\u2192 match \u2500\u2500\u2192 classify \u2500\u2500\u2192 summarize \u2500\u2500\u2192 JSON\n             \u2502         \u2502           \u2502         \u2502            \u2502\n             \u2502         \u2502           \u2502         \u2502            \u2514\u2500 tiered summaries\n             \u2502         \u2502           \u2502         \u2514\u2500 added/removed/modified/moved\n             \u2502         \u2502           \u2514\u2500 name-match old\u2194new symbols (O(n) dict)\n             \u2502         \u2514\u2500 tree-sitter queries \u2192 functions, classes, methods\n             \u2514\u2500 py-tree-sitter parses old + new file versions\n</code></pre> <p>Typical timing: ~200ms for a 1000-line diff.</p>"},{"location":"architecture/#modules","title":"Modules","text":"<p>Each module has a single responsibility. No horizontal imports between engine modules.</p> Module Input Output Responsibility <code>cli.py</code> CLI args exit code + JSON/text Click CLI entry point. Commands: <code>review</code>, <code>summarize</code>, <code>context</code> (hidden alias for review), <code>install-hook</code>. Orchestrates pipeline and determines output. <code>git.py</code> ref range changed files + old/new content All git subprocess calls. Nothing else touches git. <code>engine/_types.py</code> \u2014 \u2014 Shared type aliases and dataclasses (<code>Symbol</code>, <code>ParseResult</code>, <code>compute_body_hash</code>). <code>engine/parser.py</code> source file syntax tree Tree-sitter parsing. No git logic, no matching. <code>engine/matcher.py</code> old symbols + new symbols matched pairs Name-based symbol matching. O(n) dict lookup. <code>engine/classifier.py</code> matched pairs classified changes Labels: added, removed, modified, moved, signature_changed. Sets <code>breaking</code> flag. <code>engine/signatures.py</code> old + new signatures breaking change flags + category labels Signature comparison. Detects parameter changes, return type changes, default value changes. <code>engine/deps.py</code> symbol names + git ref external references Dependency/caller detection. Uses <code>git grep</code> to pre-filter, then tree-sitter to confirm references in non-diff files. <code>engine/summarizer.py</code> classified changes tiered text Generates oneliner, short, detailed summaries. <code>engine/pipeline.py</code> ref range + content provider <code>DiffGuardOutput</code> Orchestrates parse \u2192 match \u2192 classify \u2192 summarize for all files. <code>schema.py</code> \u2014 \u2014 Pydantic models. The contract."},{"location":"architecture/#language-plugin-system","title":"Language plugin system","text":"<p>The <code>languages/</code> package provides per-language tree-sitter support. Each language module (e.g., <code>languages/python/__init__.py</code>) exports:</p> Function Purpose <code>get_language()</code> Returns the <code>tree_sitter.Language</code> object <code>extract_symbols(tree, source)</code> Walks the parsed tree and returns <code>list[Symbol]</code> <p>The top-level <code>languages/__init__.py</code> provides:</p> <ul> <li><code>SUPPORTED_LANGUAGES</code> \u2014 set of supported language names</li> <li><code>detect_language(filename)</code> \u2014 maps file extensions to language names</li> <li><code>get_parser(language)</code> \u2014 returns a configured <code>tree_sitter.Parser</code></li> <li><code>get_language_module(language)</code> \u2014 dynamically imports the language module</li> </ul> <p><code>languages/_utils.py</code> contains shared helpers (e.g., <code>node_text()</code> for safe node text extraction).</p>"},{"location":"architecture/#supported-languages","title":"Supported languages","text":"Language Module Grammar Python <code>languages/python/</code> tree-sitter-python TypeScript <code>languages/typescript/</code> tree-sitter-typescript JavaScript <code>languages/typescript/</code> (shared) tree-sitter-javascript Go <code>languages/go/</code> tree-sitter-go"},{"location":"architecture/#symbol-extraction","title":"Symbol extraction","text":"<p>DiffGuard uses tree-sitter to parse source files and walk the AST to extract:</p> <ul> <li>Function/method definitions with signatures</li> <li>Class/struct/interface definitions</li> <li>Line numbers and scope</li> <li>Body hashes for change detection</li> </ul> <p>For each changed file, DiffGuard parses both the old and new versions, extracts symbols from each, then matches them by name.</p>"},{"location":"architecture/#matching-algorithm","title":"Matching algorithm","text":"<ol> <li>Build a dict of old symbols keyed by <code>(name, kind)</code></li> <li>Build a dict of new symbols keyed by <code>(name, kind)</code></li> <li>Symbols in both \u2192 modified (compare bodies/signatures)</li> <li>Symbols only in old \u2192 removed</li> <li>Symbols only in new \u2192 added</li> <li>Removed symbol name appears in a different file as added \u2192 moved</li> </ol> <p>This is O(n) and handles the common case well. It deliberately does not attempt fuzzy rename detection \u2014 accuracy over comprehensiveness.</p>"},{"location":"architecture/#selective-trigger","title":"Selective trigger","text":"<p>DiffGuard's core design principle: stay silent when there's nothing useful to say.</p> <p>The <code>review</code> command checks for high-signal changes before producing output. If none are found, it exits with code 0 (silence). The logic lives in <code>cli.py::_has_high_signal_changes()</code>:</p> <p>A change is high-signal if any of these are true:</p> Trigger What it means Signature changed <code>before_signature</code> and <code>after_signature</code> both present \u2014 function contract changed Breaking change <code>breaking=True</code> \u2014 callers may break Symbol removed <code>kind</code> ends with <code>_removed</code> \u2014 dependents will break Symbol moved <code>kind == \"moved\"</code> \u2014 imports need updating <p>Body-only changes (same signature, different implementation) are not high-signal \u2014 they're internal refactors that don't affect callers.</p> <p>Dependency references (<code>deps.py</code>) provide context about who is affected, but don't independently trigger output. A moved function with 12 importers is high-signal because of the move, not because of the importers.</p>"},{"location":"architecture/#signature-change-categories","title":"Signature change categories","text":"<p>When a signature change is detected, <code>signatures.py::classify_signature_change()</code> provides a specific category label:</p> Category Meaning <code>PARAMETER REMOVED</code> Positional or keyword-only parameter removed <code>PARAMETER ADDED (BREAKING)</code> New parameter without a default value <code>RETURN TYPE CHANGED</code> Return type annotation changed <code>DEFAULT VALUE CHANGED</code> Only difference is a changed default value on existing params <code>BREAKING SIGNATURE CHANGE</code> Other breaking change (type change, reorder, etc.) <code>SIGNATURE CHANGED</code> Non-breaking signature change"},{"location":"architecture/#change-kinds-in-schema","title":"Change kinds in schema","text":"<p>The <code>SymbolChange.kind</code> field uses these values:</p> Kind Description <code>function_added</code> New function <code>function_removed</code> Function deleted <code>function_modified</code> Function body changed (signature intact) <code>class_added</code> New class <code>class_removed</code> Class deleted <code>class_modified</code> Class body changed (signature intact) <code>signature_changed</code> Function/class signature changed (check <code>breaking</code> flag) <code>moved</code> Symbol moved to a different file"},{"location":"architecture/#exit-codes","title":"Exit codes","text":""},{"location":"architecture/#review-command","title":"<code>review</code> command","text":"Code Meaning 0 No high-signal findings \u2014 silence. The agent should move on. 1 Findings present \u2014 the agent should read the output. 2 Error (invalid ref range, git failure, etc.)"},{"location":"architecture/#summarize-command","title":"<code>summarize</code> command","text":"Code Meaning 0 Success 3 No changes in diff 4 Partial \u2014 parse errors in some files"},{"location":"architecture/#dependency-scanning","title":"Dependency scanning","text":"<p><code>deps.py::find_references()</code> locates callers of changed symbols in files outside the diff:</p> <ol> <li>Pre-filter with <code>git grep</code> \u2014 textually search for symbol names across the repo (fast)</li> <li>Confirm with tree-sitter \u2014 parse candidate files, walk the AST for identifier nodes matching symbol names</li> <li>Classify context \u2014 each reference is labeled <code>\"import\"</code> or <code>\"call\"</code> based on parent node types</li> </ol> <p>This two-stage approach avoids parsing every file in the repo while maintaining accuracy.</p>"},{"location":"architecture/#graceful-degradation","title":"Graceful degradation","text":"<ul> <li>Unsupported language: File included in output with <code>unsupported_language: true</code>, line-level stats only.</li> <li>Parse error: File included with <code>parse_error: true</code>, falls back to line-level stats.</li> <li>Binary file: Skipped with <code>binary: true</code>.</li> </ul> <p>DiffGuard never crashes on unsupported input. It always produces valid JSON.</p>"},{"location":"architecture/#stack","title":"Stack","text":"<ul> <li>Python \u2014 fast enough with native tree-sitter bindings</li> <li>py-tree-sitter \u2014 C-speed parsing, pre-built binaries for 40+ languages</li> <li>Pydantic v2 \u2014 schema definition and validation</li> <li>Click \u2014 CLI framework</li> <li>difflib \u2014 per-function body comparison (no GumTree, no full AST diff)</li> </ul>"},{"location":"architecture/#why-not-these-alternatives","title":"Why not these alternatives","text":"Alternative Why not GumTree O(n\u00b3), Java dependency, killed v1 Rust/TypeScript core Premature optimization. Python + native tree-sitter is fast enough. difftastic Line-oriented JSON output, not semantic. Great visual tool, wrong abstraction. ast-grep Pattern search, not a differ. Possible future add-on."},{"location":"claude-md-snippet/","title":"CLAUDE.md Snippet for DiffGuard","text":"<p>Add this to your repo's <code>CLAUDE.md</code> to enable DiffGuard in Claude Code.</p>"},{"location":"claude-md-snippet/#one-liner-recommended","title":"One-liner (recommended)","text":"<pre><code>Before reviewing any PR or diff, run: `diffguard review &lt;base&gt;..HEAD`\n</code></pre>"},{"location":"claude-md-snippet/#expanded-config","title":"Expanded config","text":"<pre><code>## Code Review\n\nBefore reviewing any PR or diff, run DiffGuard to identify high-signal changes:\n\n    diffguard review &lt;base&gt;..HEAD\n\n- Exit code 0 \u2192 nothing noteworthy, skip review commentary on structural changes\n- Exit code 1 \u2192 findings present, read the output and address each item\n- Use `--format json` for structured output if you need to process findings programmatically\n</code></pre>"},{"location":"claude-md-snippet/#example-output","title":"Example output","text":"<pre><code>\u26a0 DiffGuard: 2 changes need review\n\n1. SIGNATURE CHANGED: process_payment(amount, currency) \u2192 process_payment(amount, currency, *, timeout=30)\n   File: src/billing/processor.py:42\n   Impact: Backward-compatible (new kwarg has default)\n   Callers: checkout.py (3 calls), subscription.py (1 call)\n\n2. SYMBOL REMOVED: `validate_coupon`\n   File: src/billing/discounts.py:15\n   Impact: 2 callers will break:\n     checkout.py:89  `validate_coupon(code)`\n     api.py:201  `validate_coupon(user_code)`\n   Review: Ensure no remaining callers depend on this symbol\n</code></pre>"},{"location":"cursor-rule-snippet/","title":"Cursor Rule for DiffGuard","text":"<p>Add this as <code>.cursor/rules/diffguard.mdc</code> in your repo.</p>"},{"location":"cursor-rule-snippet/#one-liner","title":"One-liner","text":"<pre><code>---\ntype: auto\ndescription: Run DiffGuard structural analysis on code changes\nglobs: [\"**/*.py\", \"**/*.ts\", \"**/*.js\", \"**/*.go\"]\n---\nBefore reviewing diffs or PRs, run `diffguard review &lt;base&gt;..HEAD` and address any findings.\n</code></pre>"},{"location":"cursor-rule-snippet/#expanded","title":"Expanded","text":"<pre><code>---\ntype: auto\ndescription: Run DiffGuard structural analysis on code changes\nglobs: [\"**/*.py\", \"**/*.ts\", \"**/*.js\", \"**/*.go\"]\n---\n## Code Review with DiffGuard\n\nWhen reviewing changes or PRs, first run:\n\n    diffguard review &lt;base&gt;..HEAD\n\n- Exit 0 = nothing noteworthy (stay silent on structural issues)\n- Exit 1 = findings to address (read and act on each)\n- Exit 2 = error (report it)\n- Use `--format json` for structured output\n</code></pre>"},{"location":"how-it-works/","title":"How It Works","text":""},{"location":"how-it-works/#the-approach-selective-trigger","title":"The approach: selective trigger","text":"<p>Most diffs don't contain structural breaks. New functions, body-only changes, formatting \u2014 none of these affect callers. DiffGuard's core design: stay silent unless the change is structurally significant.</p> <p>This means DiffGuard only reports when it finds:</p> Trigger What it means Signature changed Function contract changed \u2014 callers may pass wrong arguments Default value changed Callers relying on the default get different behavior silently Symbol removed Dependents will break Symbol moved Imports need updating <p>Body-only changes (same signature, different implementation) are internal refactors. They don't affect callers. DiffGuard ignores them.</p>"},{"location":"how-it-works/#the-pipeline","title":"The pipeline","text":"<pre><code>git diff \u2192 parse \u2192 extract \u2192 match \u2192 classify \u2192 scan callers \u2192 output (or silence)\n</code></pre> <ol> <li>Parse the diff \u2014 tree-sitter builds ASTs for before/after versions of each changed file. Not regex \u2014 full syntax trees.</li> <li>Extract symbols \u2014 functions, classes, methods with full signatures, line numbers, and scope.</li> <li>Match old \u2194 new \u2014 O(n) dict-based name matching. No fuzzy rename detection (accuracy over comprehensiveness).</li> <li>Classify changes \u2014 labels each symbol: added, removed, modified, moved, signature_changed. Sets <code>breaking</code> flag where applicable.</li> <li>Scan for callers \u2014 two-stage: <code>git grep</code> pre-filters for speed, then tree-sitter confirms references in non-diff files.</li> <li>Apply selective trigger \u2014 only produce output if high-signal changes exist AND have external callers.</li> </ol> <p>Typical timing: ~200ms for a 1000-line diff.</p>"},{"location":"how-it-works/#why-tree-sitter","title":"Why tree-sitter","text":"<p>Tree-sitter provides C-speed parsing with pre-built binaries for 40+ languages. It gives DiffGuard real syntax trees instead of regex-based guesses. Adding a new language is mechanical: grammar + query patterns.</p> <p>Currently supported: Python (most mature), TypeScript/JavaScript, Go. More planned.</p>"},{"location":"how-it-works/#precision-over-recall","title":"Precision over recall","text":"<p>We tested three iterations before landing on the current design.</p> <p>Early versions tried to report on every structural change in a diff. A/B testing against 12 real commits from Flask, FastAPI, Pydantic, and httpx showed that most PRs don't benefit from structural analysis \u2014 the reviewer can read the diff fine on their own.</p> <p>The selective trigger changed the results:</p> Metric Result Precision 100% \u2014 when it spoke, it was right Silence rate 58% \u2014 stayed quiet on 7 of 12 PRs False positives 0 <p>The key insight: making silence the default turned a marginally useful tool into a precision instrument. A tool that says \"<code>redirect()</code> default changed from 302 to 303, 7 callers affected\" is always right. A tool that comments on every PR trains you to ignore it.</p>"},{"location":"how-it-works/#what-agents-get","title":"What agents get","text":"<p>Without DiffGuard, an AI reviewing a PR sees: <pre><code>-def redirect(location, code=302, Response=None):\n+def redirect(location, code=303, Response=None):\n</code></pre></p> <p>With DiffGuard: <pre><code>DEFAULT VALUE CHANGED: redirect(location, code=302) \u2192 redirect(location, code=303)\nImpact: 5 callers rely on the default:\n  auth.py:25  `return redirect(url_for(\"auth.login\"))`\n  auth.py:77  `return redirect(url_for(\"index\"))`\n  blog.py:81  `return redirect(url_for(\"blog.index\"))`\nReview: Verify callers expect HTTP 303 instead of 302\n</code></pre></p> <p>The difference: \"I see a number changed\" vs. \"I see a behavioral change that affects 5 call sites across 3 files.\"</p>"},{"location":"how-it-works/#limitations","title":"Limitations","text":"<p>DiffGuard's value scales with PR size:</p> PR size Value Small (&lt;100 lines, 1-2 files) Minimal. The reviewer can read the whole diff. Medium (200-500 lines) Moderate. Structural overview saves time. Large (500+ lines, multiple files) Significant. Linear reading of 1000+ lines misses structural patterns. <p>DiffGuard is not magic. On small, focused PRs, you don't need it.</p> <p>For detailed internals, see Architecture.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#install","title":"Install","text":"<pre><code>pip install diffguard\n</code></pre>"},{"location":"quickstart/#diffguard-review-the-primary-command","title":"<code>diffguard review</code> \u2014 the primary command","text":"<p>Surfaces high-signal structural changes. Silent when nothing is noteworthy.</p> <pre><code># Review last commit\ndiffguard review HEAD~1..HEAD\n\n# Review a PR branch\ndiffguard review main..feature-branch\n</code></pre>"},{"location":"quickstart/#exit-codes","title":"Exit codes","text":"Code Meaning 0 No high-signal findings (no output) 1 Findings present \u2014 read stdout 2 Error"},{"location":"quickstart/#example-output-text","title":"Example output (text)","text":"<pre><code>\u26a0 DiffGuard: 2 changes need review\n\n1. DEFAULT VALUE CHANGED: redirect(location, code=302, Response) \u2192 redirect(location, code=303, Response)\n   File: src/flask/helpers.py:241\n   Impact: 7 callers rely on the default:\n     auth.py:25   `return redirect(url_for(\"auth.login\"))`\n     auth.py:77   `return redirect(url_for(\"auth.login\"))`\n     auth.py:105  `return redirect(url_for(\"index\"))`\n     blog.py:81   `return redirect(url_for(\"blog.index\"))`\n   Review: Verify callers expect the new default value\n\n2. DEFAULT VALUE CHANGED: App.redirect(self, location, code=302) \u2192 App.redirect(self, location, code=303)\n   File: src/flask/sansio/app.py:935\n   Impact: 7 callers rely on the default\n   Review: Verify callers expect the new default value\n</code></pre> <p>Real output from DiffGuard run against Flask commit <code>eca5fd1d</code>.</p>"},{"location":"quickstart/#example-output-json","title":"Example output (JSON)","text":"<pre><code>diffguard review HEAD~1..HEAD --format json\n</code></pre> <p>When there are no findings:</p> <pre><code>{\n  \"version\": \"0.1.0\",\n  \"ref_range\": \"HEAD~1..HEAD\",\n  \"findings\": [],\n  \"stats\": {\n    \"files_analyzed\": 1,\n    \"symbols_changed\": 0,\n    \"silence_reason\": \"no high-signal changes\"\n  }\n}\n</code></pre> <p>See Schema Reference for the full schema.</p>"},{"location":"quickstart/#diffguard-summarize-full-structural-summary","title":"<code>diffguard summarize</code> \u2014 full structural summary","text":"<p>Always produces output. Gives a complete map of what changed structurally \u2014 useful for agents that want the full picture, not just the high-signal items.</p> <pre><code># Summarize last commit\ndiffguard summarize HEAD~1..HEAD\n\n# Choose output tier\ndiffguard summarize HEAD~1..HEAD --format oneliner\ndiffguard summarize HEAD~1..HEAD --format short\ndiffguard summarize HEAD~1..HEAD --format json\n</code></pre>"},{"location":"quickstart/#example-output-json_1","title":"Example output (JSON)","text":"<pre><code>{\n  \"schema_version\": \"1.1\",\n  \"meta\": {\n    \"ref_range\": \"abc1234..def5678\",\n    \"stats\": { \"files\": 3, \"additions\": 340, \"deletions\": 89 },\n    \"warnings\": [],\n    \"timing_ms\": 187.4\n  },\n  \"files\": [\n    {\n      \"path\": \"src/auth/client.ts\",\n      \"language\": \"typescript\",\n      \"change_type\": \"modified\",\n      \"changes\": [\n        {\n          \"kind\": \"function_removed\",\n          \"name\": \"authenticate\",\n          \"signature\": \"authenticate(apiKey: string): Promise&lt;Session&gt;\",\n          \"line\": 45,\n          \"breaking\": true\n        }\n      ]\n    }\n  ],\n  \"summary\": {\n    \"change_types\": { \"feature\": 1, \"refactor\": 2 },\n    \"breaking_changes\": [...],\n    \"focus\": [\"authenticate() removed \u2014 callers need migration\"]\n  },\n  \"tiered\": {\n    \"oneliner\": \"Replace API key auth with OAuth2 PKCE; 2 breaking changes\",\n    \"short\": \"Removes authenticate(apiKey), adds authenticateOAuth(config)...\",\n    \"detailed\": \"...\"\n  }\n}\n</code></pre> <p>Illustrative example</p> <p>The JSON above is illustrative of the schema structure. Field names and types match the real schema \u2014 see Schema Reference for details.</p> <p>See Schema Reference for the full output format.</p>"},{"location":"quickstart/#when-to-use-which","title":"When to use which","text":"Scenario Command CI gate / pre-review check <code>diffguard review</code> Agent needs full structural map <code>diffguard summarize</code> Quick \"anything breaking?\" check <code>diffguard review</code> Feeding context to an AI reviewer <code>diffguard summarize --format json</code>"},{"location":"quickstart/#what-diffguard-tells-you","title":"What DiffGuard tells you","text":"<p>DiffGuard reports structural facts: which functions changed, what signatures broke, what was removed, which callers are affected.</p> <p>It does not tell you why something changed, whether the logic is correct, or whether it's a good idea. That's the reviewer's job.</p> <p>Scope: Signatures, removed symbols, default value changes. Not logic, security, or performance.</p>"},{"location":"real-world-catches/","title":"Real-World Catches: DiffGuard vs. Historical OSS Bugs","text":"<p>These are real commits in real repos where DiffGuard flags exactly what went wrong \u2014 before users found out the hard way.</p>"},{"location":"real-world-catches/#1-flask-redirect-default-changed-from-302-303","title":"1. \ud83c\udfc6 Flask: <code>redirect()</code> default changed from 302 \u2192 303","text":"<p>Repo: pallets/flask Commit: <code>eca5fd1d</code> (merged via PR #5898) Issue: #5895 Milestone: Flask 3.2.0</p>"},{"location":"real-world-catches/#what-changed","title":"What changed","text":"<p>The <code>redirect()</code> function's <code>code</code> parameter default changed from <code>302</code> to <code>303</code>:</p> <pre><code># Before\ndef redirect(location: str, code: int = 302, ...) -&gt; BaseResponse:\n\n# After\ndef redirect(location: str, code: int = 303, ...) -&gt; BaseResponse:\n</code></pre>"},{"location":"real-world-catches/#why-it-matters","title":"Why it matters","text":"<p>HTTP 302 and 303 have subtly different semantics. 302 sometimes preserves the HTTP method (browser-dependent), while 303 always converts to GET. Any caller relying on 302's method-preservation behavior (e.g., API endpoints expecting POST\u2192POST redirects) would silently break \u2014 no errors, just different behavior.</p>"},{"location":"real-world-catches/#diffguards-output","title":"DiffGuard's output","text":"<p>Signature display simplified for readability \u2014 run the command yourself to see parameter type annotations.</p> <pre><code>\u26a0 DiffGuard: 2 changes need review\n\n1. DEFAULT VALUE CHANGED: redirect(location, code=302, Response) \u2192 redirect(location, code=303, Response)\n   File: src/flask/helpers.py:241\n   Impact: 7 callers rely on the default:\n     auth.py:25   `return redirect(url_for(\"auth.login\"))`\n     auth.py:77   `return redirect(url_for(\"auth.login\"))`\n     auth.py:105  `return redirect(url_for(\"index\"))`\n     blog.py:81   `return redirect(url_for(\"blog.index\"))`\n   Review: Verify callers expect the new default value\n\n2. DEFAULT VALUE CHANGED: App.redirect(self, location, code=302) \u2192 App.redirect(self, location, code=303)\n   File: src/flask/sansio/app.py:935\n   Impact: 7 callers rely on the default\n   Review: Verify callers expect the new default value\n</code></pre>"},{"location":"real-world-catches/#why-this-is-a-great-story","title":"Why this is a great story","text":"<ul> <li>Flask is one of the most popular Python web frameworks (~70k GitHub stars)</li> <li>The change is intentional but silently breaks callers \u2014 no TypeError, no warning</li> <li>DiffGuard identifies the exact callers that rely on the default and need verification</li> <li>A human reviewer could easily miss the behavioral difference between 302 and 303</li> </ul> <p>Headline: \"DiffGuard would have caught Flask PR #5898 before it shipped.\"</p>"},{"location":"real-world-catches/#2-httpx-requestmethod-narrows-from-str-bytes-to-str","title":"2. httpx: <code>Request(method=)</code> narrows from <code>str | bytes</code> to <code>str</code>","text":"<p>Repo: encode/httpx Commit: <code>6622553</code> (PR #3378)</p>"},{"location":"real-world-catches/#what-changed_1","title":"What changed","text":"<p>The <code>Request.__init__()</code> <code>method</code> parameter type was narrowed from <code>str | bytes</code> to <code>str</code>:</p> <pre><code># Before\nclass Request:\n    def __init__(self, method: str | bytes, url: URL | str, ...):\n\n# After\nclass Request:\n    def __init__(self, method: str, url: URL | str, ...):\n</code></pre>"},{"location":"real-world-catches/#why-it-matters_1","title":"Why it matters","text":"<p>Any code passing <code>method=b\"GET\"</code> (bytes) would break with an <code>AttributeError</code> on <code>method.upper()</code> at runtime. The PR author acknowledged this was \"nominally an API change\" but believed it was a \"bugfix in practice.\" Still \u2014 silent breakage for anyone using bytes.</p>"},{"location":"real-world-catches/#diffguards-output_1","title":"DiffGuard's output","text":"<pre><code>\u26a0 DiffGuard: 1 change needs review\n\n1. SIGNATURE CHANGED: __init__(self, method: str | bytes, ...) \u2192 __init__(self, method: str, ...)\n   File: httpx/_models.py:311\n   Impact: 63 callers rely on the default\n   Review: Check all callers handle the new signature\n</code></pre>"},{"location":"real-world-catches/#why-this-is-a-great-story_1","title":"Why this is a great story","text":"<ul> <li>httpx is the modern Python HTTP client (~13k stars), used by FastAPI's test client</li> <li>Type narrowing is exactly the kind of \"looks harmless\" change that breaks real code</li> <li>DiffGuard catches it instantly \u2014 no need to read the diff line-by-line</li> </ul>"},{"location":"real-world-catches/#3-pydantic-serializer-renamed-to-field_serializer-symbol-removed","title":"3. Pydantic: <code>@serializer</code> renamed to <code>@field_serializer</code> (symbol removed)","text":"<p>Repo: pydantic/pydantic Commit: <code>11edcb2c</code> (PR #5331)</p>"},{"location":"real-world-catches/#what-changed_2","title":"What changed","text":"<p>The <code>@serializer</code> decorator was renamed to <code>@field_serializer</code>, and a new <code>@model_serializer</code> was added alongside it. The old name was removed entirely.</p>"},{"location":"real-world-catches/#diffguards-output_2","title":"DiffGuard's output","text":"<pre><code>\u26a0 DiffGuard: 5 changes need review\n\n1. PARAMETER ADDED (BREAKING): make_generic_field_serializer(serializer, mode)\n   \u2192 make_generic_field_serializer(serializer, mode, type)\n   Impact: Breaking change \u2014 callers will break with missing required argument\n\n2. SYMBOL REMOVED: serializer(__field, *fields, ...)\n   File: pydantic/decorators.py:341\n   Impact: 19 callers will break\n\n3-4. (additional overloads of the removed symbol)\n\n5. SYMBOL REMOVED: serializer(__field, *fields, mode='wrap', ...)\n   Impact: 19 callers will break\n</code></pre>"},{"location":"real-world-catches/#why-this-is-a-great-story_2","title":"Why this is a great story","text":"<ul> <li>Pydantic v2 was the biggest Python library migration in recent memory</li> <li>DiffGuard catches both the symbol removal AND identifies 19 internal callers that reference it</li> <li>This is the kind of rename that grep can find, but DiffGuard does it automatically as part of review</li> </ul>"},{"location":"real-world-catches/#dogfooding-notes","title":"Dogfooding Notes","text":"<p>While running DiffGuard on these repos, I noted:</p> <ol> <li> <p>Missed catch \u2014 Django <code>UniqueConstraint(name=None)</code> \u2192 <code>UniqueConstraint(name)</code> (commit <code>b172cbdf33</code>): A parameter changed from optional (<code>name=None</code>) to required (<code>name</code>). DiffGuard returned exit 0 with no findings. This is a false negative \u2014 removing a default value is a breaking change. Filed as a potential improvement.</p> </li> <li> <p>Output verbosity on httpx proxy commit: 14 findings for the proxies\u2192proxy migration. The output is very long. A summary mode or grouping related changes (e.g., \"proxy parameter added to 9 HTTP method functions\") would help for large refactors.</p> </li> <li> <p>Caller detection quality: DiffGuard correctly identifies callers in both source and test files, which is excellent. The Flask example showing <code>auth.py</code> and <code>blog.py</code> callers makes the impact immediately tangible.</p> </li> <li> <p>Speed: All reviews completed in under 5 seconds on these repos. Fast enough for CI integration.</p> </li> </ol>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Last updated: 2026-02-11</p>"},{"location":"roadmap/#vision","title":"Vision","text":"<p>DiffGuard is a verification layer for code changes. Not a reviewer (opinions) \u2014 a verifier (facts).</p> <ul> <li>Human hook: \"Catches the bugs that pass code review\"</li> <li>Technical hook: \"Precision verification for AI-native workflows\"</li> </ul> <p>Works for both humans (VS Code/Cursor devs) and AI agents (Claude Code, OpenClaw, pipelines). Local-first, privacy-first, agent-native CLI. Your code never leaves your machine.</p>"},{"location":"roadmap/#competitive-context","title":"Competitive context","text":"Tool Model Limitation CodeRabbit SaaS, $15-30/seat Code leaves your machine. Reviews on their servers. Aider repo-map tree-sitter + PageRank Locked inside Aider. Not usable standalone. ast-grep Pattern search CLI Searches, doesn't diff. No semantic change detection. semgrep Static analysis rules Security-focused. Not a change reviewer. GitHub Copilot review SaaS, GitHub-only Vendor lock-in. No local option. claude-code-action GitHub Action, runs on your runner Broad review, not precision bug detection. Complementary to DiffGuard \u2014 DiffGuard triages, claude-code-action reviews what matters. <p>DiffGuard is the only open-source, local-first, agent-native option.</p>"},{"location":"roadmap/#license","title":"License","text":"<p>BSL 1.1 \u2014 see LICENSE for details.</p>"},{"location":"roadmap/#phases","title":"Phases","text":""},{"location":"roadmap/#phase-1-ship-it-now-4-weeks","title":"Phase 1: Ship it (Now \u2192 4 weeks)","text":"<p>Status: current</p> <p>Goals: - Ship CLI to PyPI (<code>pip install diffguard</code>) - Integration snippets for CLAUDE.md, Cursor rules, Aider - Launch post</p> <p>Gate criteria: - 50 installs in first 30 days - 5 distinct users in 30 days</p> <p>Kill signals: - &lt;20 installs after 30 days with active promotion</p>"},{"location":"roadmap/#phase-2-ci-integration-weeks-510","title":"Phase 2: CI integration (Weeks 5\u201310)","text":"<p>Status: planned</p> <p>Goals: - GitHub Action (<code>diffguard-action</code>) - <code>--ci</code> mode (non-interactive, structured output) - Team config file (<code>.diffguard.yml</code>) - <code>--fail-on</code> severity flag for CI gates - claude-code-action + DiffGuard integration example (show them running together) - \"Bugs AI reviewers miss\" benchmark \u2014 test DiffGuard against AI-generated code, publish results - Ensure <code>--format json</code> output has severity, confidence, location fields for agent consumption</p> <p>Gate criteria: - &gt;100 weekly active users (WAU)</p> <p>Kill signals: - &lt;50 WAU despite GitHub Action availability</p>"},{"location":"roadmap/#phase-3-watch-mode-weeks-1116","title":"Phase 3: Watch mode (Weeks 11\u201316)","text":"<p>Status: planned</p> <p>Goals: - <code>diffguard watch</code> \u2014 daemon mode, incremental review on file save - Context hints \u2014 suggest related files/symbols for the agent - Rust and Java language support</p> <p>Gate criteria: - Sustained growth in WAU - Community requests for daemon mode</p> <p>Kill signals: - No organic demand for watch mode after Phase 2 traction</p>"},{"location":"roadmap/#future-proof-thesis","title":"Future-Proof Thesis","text":"<p>As AI generates more code, the need for automated verification increases, not decreases. Human review capacity is fixed. AI-generated code volume is exponential. The bottleneck shifts from \"who writes the code\" to \"who verifies the code is correct.\" DiffGuard is a verification engine that works regardless of whether code was written by a human, Cursor, Claude Code, or a fully autonomous agent swarm. The less human oversight there is in the loop, the more critical precision-targeted bug detection becomes.</p> <p>DiffGuard is infrastructure (model-agnostic pre-processor), not a model wrapper. CLI-first design is already positioned for the agentic future.</p>"},{"location":"roadmap/#kill-continue-signals","title":"Kill / continue signals","text":"Milestone Signal Action Month 1 &gt;50 installs Continue to Phase 2 Month 3 &gt;100 WAU, &gt;200 GitHub stars Continue to Phase 3 Month 6 External contributors appearing Project has legs \u2014 invest more Month 1 &lt;20 installs Reassess positioning or pivot Month 3 &lt;50 WAU Consider stopping active development"},{"location":"schema/","title":"Schema Reference","text":"<p>DiffGuard has two commands with different JSON output schemas.</p>"},{"location":"schema/#review-output","title":"Review output","text":"<p><code>diffguard review &lt;ref-range&gt; --format json</code></p> <p>The review command outputs a flat list of high-signal findings. When there are no findings, <code>findings</code> is empty and <code>silence_reason</code> explains why.</p>"},{"location":"schema/#top-level","title":"Top-level","text":"Field Type Description <code>version</code> <code>str</code> Schema version (currently <code>\"0.1.0\"</code>) <code>ref_range</code> <code>str</code> Git ref range analyzed <code>findings</code> <code>list[Finding]</code> High-signal findings (may be empty) <code>stats</code> <code>ReviewStats</code> Analysis statistics"},{"location":"schema/#reviewstats","title":"<code>ReviewStats</code>","text":"Field Type Description <code>files_analyzed</code> <code>int</code> Number of files analyzed <code>symbols_changed</code> <code>int</code> Total symbol-level changes detected <code>silence_reason</code> <code>str | null</code> Why no findings were reported (null if findings exist)"},{"location":"schema/#finding","title":"<code>Finding</code>","text":"Field Type Description <code>category</code> <code>str</code> One of: <code>DEFAULT_VALUE_CHANGED</code>, <code>SIGNATURE_CHANGED</code>, <code>SYMBOL_REMOVED</code>, <code>PARAMETER_ADDED</code>, <code>PARAMETER_REMOVED</code>, <code>MOVED</code> <code>symbol</code> <code>str</code> Symbol name <code>file</code> <code>str</code> File path <code>line</code> <code>int | null</code> Line number <code>before_signature</code> <code>str</code> Previous signature (when applicable) <code>after_signature</code> <code>str</code> New signature (when applicable) <code>impact</code> <code>Impact</code> Caller impact analysis <code>review_hint</code> <code>str</code> Suggested reviewer action"},{"location":"schema/#impact","title":"<code>Impact</code>","text":"Field Type Description <code>production_callers</code> <code>int</code> Number of non-test callers <code>test_callers</code> <code>int</code> Number of test callers <code>callers</code> <code>list[Caller]</code> Up to 10 caller locations"},{"location":"schema/#caller","title":"<code>Caller</code>","text":"Field Type Description <code>file</code> <code>str</code> File path <code>line</code> <code>int</code> Line number <code>source</code> <code>str</code> Source line text"},{"location":"schema/#example","title":"Example","text":"<pre><code>{\n  \"version\": \"0.1.0\",\n  \"ref_range\": \"eca5fd1d~1..eca5fd1d\",\n  \"findings\": [\n    {\n      \"category\": \"DEFAULT_VALUE_CHANGED\",\n      \"symbol\": \"redirect\",\n      \"file\": \"src/flask/helpers.py\",\n      \"line\": 241,\n      \"before_signature\": \"def redirect(location, code=302, Response=None)\",\n      \"after_signature\": \"def redirect(location, code=303, Response=None)\",\n      \"impact\": {\n        \"production_callers\": 7,\n        \"test_callers\": 2,\n        \"callers\": [\n          {\"file\": \"auth.py\", \"line\": 25, \"source\": \"return redirect(url_for(\\\"auth.login\\\"))\"}\n        ]\n      },\n      \"review_hint\": \"Verify callers expect the new default value\"\n    }\n  ],\n  \"stats\": {\n    \"files_analyzed\": 2,\n    \"symbols_changed\": 2,\n    \"silence_reason\": null\n  }\n}\n</code></pre> <p>Illustrative</p> <p>This example is based on real DiffGuard output against Flask commit <code>eca5fd1d</code>, with some fields simplified for clarity. Field names and types are accurate.</p>"},{"location":"schema/#summarize-output","title":"Summarize output","text":"<p><code>diffguard summarize &lt;ref-range&gt; --format json</code></p> <p>The summarize command outputs a complete structural map of the diff. Defined by Pydantic v2 models in <code>src/diffguard/schema.py</code>.</p>"},{"location":"schema/#diffguardoutput-top-level","title":"<code>DiffGuardOutput</code> (top-level)","text":"Field Type Description <code>schema_version</code> <code>str</code> Currently <code>\"1.1\"</code> <code>meta</code> <code>Meta</code> Run metadata: ref range, stats, timing <code>files</code> <code>list[FileChange]</code> Per-file semantic changes <code>summary</code> <code>Summary</code> Aggregate: change types, breaking changes, focus areas <code>tiered</code> <code>TieredSummary</code> Human-readable summaries at different token budgets"},{"location":"schema/#meta","title":"<code>Meta</code>","text":"Field Type Description <code>ref_range</code> <code>str</code> Git ref range analyzed <code>stats</code> <code>DiffStats</code> <code>files</code>, <code>additions</code>, <code>deletions</code> counts <code>warnings</code> <code>list[str]</code> Parse errors, truncation signals <code>timing_ms</code> <code>float | None</code> Wall-clock time for analysis"},{"location":"schema/#filechange","title":"<code>FileChange</code>","text":"Field Type Description <code>path</code> <code>str</code> File path relative to repo root <code>language</code> <code>str | None</code> Detected language <code>change_type</code> <code>\"added\" | \"removed\" | \"modified\" | \"renamed\"</code> File-level change type <code>generated</code> <code>bool</code> Lock files, protobuf output, etc. <code>binary</code> <code>bool</code> Binary file (skipped) <code>parse_error</code> <code>bool</code> Tree-sitter couldn't parse this file <code>unsupported_language</code> <code>bool</code> No grammar available <code>changes</code> <code>list[SymbolChange]</code> Symbol-level changes"},{"location":"schema/#symbolchange","title":"<code>SymbolChange</code>","text":"Field Type Description <code>kind</code> <code>str</code> One of: <code>function_added</code>, <code>function_removed</code>, <code>function_modified</code>, <code>class_added</code>, <code>class_removed</code>, <code>class_modified</code>, <code>signature_changed</code>, <code>moved</code> <code>name</code> <code>str</code> Symbol name <code>signature</code> <code>str | None</code> Full signature (for added/removed) <code>before_signature</code> <code>str | None</code> Old signature (for <code>signature_changed</code>) <code>after_signature</code> <code>str | None</code> New signature (for <code>signature_changed</code>) <code>file_from</code> <code>str | None</code> Source file (for <code>moved</code>) <code>line</code> <code>int | None</code> Line number in new file <code>breaking</code> <code>bool</code> Whether this breaks the public API <code>detail</code> <code>dict | None</code> Language-specific metadata"},{"location":"schema/#summary","title":"<code>Summary</code>","text":"Field Type Description <code>change_types</code> <code>dict[str, int]</code> Counts by category <code>breaking_changes</code> <code>list[SymbolChange]</code> All breaking changes <code>focus</code> <code>list[str]</code> Most important items for reviewer attention"},{"location":"schema/#tieredsummary","title":"<code>TieredSummary</code>","text":"Field Type Description <code>oneliner</code> <code>str</code> ~20 tokens <code>short</code> <code>str</code> ~80 tokens <code>detailed</code> <code>str</code> Full narrative"},{"location":"schema/#design-principles","title":"Design principles","text":"<ul> <li>Semantic change units. Function/class level with signatures \u2014 not line numbers.</li> <li>Breaking changes at top level. Not buried in file details.</li> <li>No opinions. Structural facts only.</li> <li>Graceful degradation. Parse errors and unsupported languages are flagged, never crashes.</li> </ul>"},{"location":"validation/","title":"Validation","text":"<p>DiffGuard has two commands, validated in different ways.</p>"},{"location":"validation/#diffguard-review-real-world-catch-validation","title":"<code>diffguard review</code> \u2014 real-world catch validation","text":"<p>The <code>review</code> command's detection capabilities are validated against real commits in real open-source projects. See Real-World Catches for full details.</p> <p>Summary of results:</p> <ul> <li>Flask: Caught <code>redirect()</code> default change from 302\u2192303, identified 7 affected callers</li> <li>httpx: Caught <code>Request(method=)</code> type narrowing from <code>str | bytes</code> to <code>str</code></li> <li>Pydantic: Caught <code>@serializer</code> removal and 19 affected callers</li> </ul> <p>Known false negative: Django <code>UniqueConstraint(name=None)</code> \u2192 <code>UniqueConstraint(name)</code> \u2014 a parameter changed from optional to required. DiffGuard returned exit 0. Filed as a potential improvement.</p> <p>Precision: Zero false positives in validation testing. DiffGuard prioritizes precision over recall \u2014 it would rather miss a minor issue than report a false positive.</p>"},{"location":"validation/#diffguard-summarize-ab-test-validation","title":"<code>diffguard summarize</code> \u2014 A/B test validation","text":"<p>We ran a controlled test to measure whether <code>summarize</code> output helps AI reviewers find more issues.</p> <p>Feature context</p> <p>This A/B test validates the <code>summarize</code> command's structural output as a review pre-pass. It does not test the <code>review</code> command's selective detection.</p>"},{"location":"validation/#setup","title":"Setup","text":"<ul> <li>Commit: 7ae6492 \u2014 944 lines changed across 3 files</li> <li>Baseline: AI reviewer with raw diff only (974 lines of diff text)</li> <li>Assisted: AI reviewer with DiffGuard <code>summarize</code> JSON output + the same raw diff</li> </ul>"},{"location":"validation/#results","title":"Results","text":"Metric Baseline Assisted Total findings 19 26 (+37%) Design-level issues 4 6 Specific missing test coverage 1 (generic) 6 (named functions) Bugs found 5 5"},{"location":"validation/#what-the-assisted-reviewer-caught-that-the-baseline-missed","title":"What the assisted reviewer caught that the baseline missed","text":"<ol> <li><code>_is_high_impact</code> dual-set case matching bug \u2014 a real logic error where <code>\"If_Statement\"</code> silently fails</li> <li><code>_get_ref_content</code> can't distinguish \"file missing\" from \"git error\" \u2014 error handling gap</li> <li><code>reshape_engine_output</code> mutates input dict \u2014 callers don't expect this</li> <li>Specific untested functions \u2014 named 6 functions with no test coverage</li> </ol>"},{"location":"validation/#what-the-baseline-caught-that-the-assisted-missed","title":"What the baseline caught that the assisted missed","text":"<ol> <li>Type annotation <code>str</code> with default <code>None</code> (should be <code>str | None</code>)</li> <li><code>ref~1</code> doesn't exist for initial commit</li> <li><code>_risk_level_value</code> returns -1 for unknown</li> </ol> <p>The baseline's unique findings were surface-level. The assisted reviewer's unique findings were structural.</p>"},{"location":"validation/#why-it-works","title":"Why it works","text":"<p>The <code>summarize</code> output gives the reviewer a map of all changed symbols before it reads the diff. Instead of scanning 974 lines linearly, it knows the shape of the change and allocates attention to the important parts.</p> <p>The <code>review</code> command goes further \u2014 it filters to only the high-signal changes and traces caller impact, so the reviewer can focus on what actually matters.</p>"},{"location":"validation/#honest-assessment","title":"Honest assessment","text":"<p>DiffGuard's value scales with PR size:</p> PR size Value added Small (&lt;100 lines, 1-2 files) Minimal. The reviewer can read the whole diff easily. Medium (200-500 lines) Moderate. Structural overview saves the reviewer from getting lost. Large (500+ lines, multiple files) Significant. Linear reading of 1000+ lines of diff misses structural patterns. <p>DiffGuard is not magic. On small, focused PRs, you don't need it. On large, multi-file changes \u2014 the kind where reviewers most often miss design issues \u2014 it earns its keep.</p>"},{"location":"validation/#philosophy-facts-not-opinions","title":"Philosophy: facts, not opinions","text":"<p>DiffGuard reports structural facts: what functions changed, what signatures broke, what moved. It does not assess risk, rate severity, or guess intent.</p> <p>A tool that says \"this change is high risk\" and is wrong erodes trust fast. A tool that says \"<code>redirect()</code> default changed from 302 to 303, 7 callers affected\" is always right \u2014 and the reviewer draws their own conclusions.</p>"},{"location":"decisions/","title":"Architecture Decision Records","text":"<p>This directory contains Architecture Decision Records (ADRs) for DiffGuard.</p>"},{"location":"decisions/#what-are-adrs","title":"What are ADRs?","text":"<p>ADRs document significant architectural decisions. Each record captures the context, the decision made, and its consequences. They're immutable once accepted \u2014 if a decision is reversed, write a new ADR that supersedes it.</p>"},{"location":"decisions/#how-to-add-one","title":"How to add one","text":"<ol> <li>Copy the template below into a new file: <code>NNN-short-title.md</code></li> <li>Fill in each section</li> <li>Add it to the index below</li> <li>Submit via PR</li> </ol>"},{"location":"decisions/#template","title":"Template","text":"<pre><code># NNN. Short title\n\n**Status:** Proposed | Accepted | Deprecated | Superseded by [NNN]\n\n## Context\n\nWhat is the issue? What forces are at play?\n\n## Decision\n\nWhat did we decide?\n\n## Consequences\n\nWhat becomes easier or harder? What are the trade-offs?\n</code></pre>"},{"location":"decisions/#index","title":"Index","text":"ADR Title Status 001 CLI-first, not MCP/GUI/web Accepted 002 Selective trigger over always-on Accepted 003 BSL 1.1 license Accepted 004 Local-first, no SaaS Accepted"},{"location":"decisions/001-cli-first/","title":"001. CLI-first, not MCP/GUI/web","text":"<p>Status: Accepted</p>"},{"location":"decisions/001-cli-first/#context","title":"Context","text":"<p>DiffGuard needs a distribution strategy that works with AI coding agents (Claude Code, Cursor, Aider, etc.). The options are:</p> <ul> <li>MCP server \u2014 Model Context Protocol, requires running a server process</li> <li>IDE plugin \u2014 per-editor, high maintenance</li> <li>Web dashboard \u2014 SaaS-like, conflicts with local-first principle</li> <li>CLI \u2014 one binary, works everywhere</li> </ul> <p>Community consensus from practitioners (steipete, Armin Ronacher, Mario Zechner) is that CLIs beat MCPs for agent tooling. One line in CLAUDE.md is enough: <code>Run diffguard review before committing.</code> No protocol negotiation, no server lifecycle, no version compatibility matrix.</p>"},{"location":"decisions/001-cli-first/#decision","title":"Decision","text":"<p>CLI-only. No MCP server, no IDE plugin, no web dashboard.</p> <p>Distribution via PyPI (<code>pip install diffguard</code>). Integration via a single instruction in the agent's project context file.</p>"},{"location":"decisions/001-cli-first/#consequences","title":"Consequences","text":"<ul> <li>Simple distribution: <code>pip install diffguard</code> works everywhere Python runs</li> <li>Agent-agnostic: Works with any agent that can run shell commands</li> <li>Low maintenance: One interface to maintain, not N plugins</li> <li>Trade-off: No visual UI for non-technical users \u2014 but they're not the target audience</li> </ul>"},{"location":"decisions/002-selective-trigger/","title":"002. Selective trigger over always-on","text":"<p>Status: Accepted</p>"},{"location":"decisions/002-selective-trigger/#context","title":"Context","text":"<p>Early testing with always-on analysis (report on every change) was noisy. A/B testing showed 2 out of 3 test scenarios had zero improvement in code quality when the tool reported on everything. Developers and agents learned to ignore it.</p> <p>The core problem: most code changes are body-only refactors that don't affect any callers. Reporting on them adds noise without value.</p>"},{"location":"decisions/002-selective-trigger/#decision","title":"Decision","text":"<p>DiffGuard only speaks when high-signal changes are detected. The trigger criteria:</p> <ul> <li>Signature changes \u2014 function contract changed, callers may need updating</li> <li>Symbol removals \u2014 dependents will break</li> <li>Default value changes \u2014 a sub-case of signature changes; subtle behavioral shift</li> <li>File moves with dependents \u2014 imports need updating</li> </ul> <p>Body-only changes (same signature, different implementation) produce silence.</p> <p>Implementation: <code>cli.py::_has_high_signal_changes()</code> checks these criteria. If none match, exit code 0 (silence).</p>"},{"location":"decisions/002-selective-trigger/#consequences","title":"Consequences","text":"<ul> <li>100% precision \u2014 when DiffGuard speaks, it's useful</li> <li>58% silence rate \u2014 most commits get no output, which is correct</li> <li>Risk: May miss some useful edge cases where body changes matter (e.g., changed semantics with same signature)</li> <li>Mitigation: <code>--verbose</code> flag forces full output for users who want it</li> </ul>"},{"location":"decisions/003-bsl-1-1-license/","title":"003. BSL 1.1 license","text":"<p>Status: Accepted (updated from Apache 2.0)</p>"},{"location":"decisions/003-bsl-1-1-license/#context","title":"Context","text":"<p>DiffGuard needs a license that:</p> <ul> <li>Protects the project's commercial viability</li> <li>Allows free use for non-production purposes</li> <li>Converts to open source after the change date</li> <li>Is clear and well-understood in the industry</li> </ul> <p>Options considered:</p> <ul> <li>MIT \u2014 simple, but no protection against competitors</li> <li>AGPL \u2014 copyleft scares enterprise adopters and acquirers</li> <li>Apache 2.0 \u2014 permissive, but allows unrestricted commercial forking</li> <li>BSL 1.1 \u2014 source-available with time-delayed open-source conversion</li> </ul>"},{"location":"decisions/003-bsl-1-1-license/#decision","title":"Decision","text":"<p>BSL 1.1. Balances openness with sustainability.</p>"},{"location":"decisions/003-bsl-1-1-license/#consequences","title":"Consequences","text":"<ul> <li>Source available \u2014 anyone can read, learn from, and contribute to the code</li> <li>Non-production use is unrestricted \u2014 development, testing, evaluation are all fine</li> <li>Commercial protection \u2014 competitors can't simply rebrand and sell</li> <li>Time-delayed open source \u2014 code converts to a permissive license after the change date</li> <li>Trade-off: Some organizations have policies against BSL \u2014 but the conversion clause mitigates long-term concerns</li> </ul>"},{"location":"decisions/004-local-first/","title":"004. Local-first, no SaaS","text":"<p>Status: Accepted</p>"},{"location":"decisions/004-local-first/#context","title":"Context","text":"<p>The primary competitor (CodeRabbit) requires sending code to their servers for analysis. For many teams \u2014 especially in regulated industries, defense, finance, healthcare \u2014 this is a non-starter. Privacy and compliance are the competitive wedge.</p>"},{"location":"decisions/004-local-first/#decision","title":"Decision","text":"<p>All processing runs locally. No telemetry, no cloud calls, no accounts, no sign-up.</p> <p>Code never leaves the developer's machine.</p>"},{"location":"decisions/004-local-first/#consequences","title":"Consequences","text":"<ul> <li>Zero setup friction \u2014 <code>pip install diffguard &amp;&amp; diffguard review</code> works immediately</li> <li>Privacy by architecture \u2014 not just a policy, structurally impossible to leak code</li> <li>Compliance-friendly \u2014 no data processing agreements needed</li> <li>Trade-off: No usage analytics \u2014 harder to understand adoption patterns</li> <li>Trade-off: Harder to monetize \u2014 no SaaS revenue model, must find alternative (support, enterprise features, etc.)</li> </ul>"}]}